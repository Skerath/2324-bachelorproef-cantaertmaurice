%%=============================================================================
%% Proof of Concept
%%=============================================================================

\chapter{\IfLanguageName{dutch}{Proof-of-concept}{Proof-of-concept}}
\label{ch:proof-of-concept}
Na de~\nameref{ch:shortlist} kan de proof-of-concept uitgewerkt worden.
Allereerst worden de omgevingen opgezet om de uitwerking mogelijk te maken.
Hierbij volgt telkens een kleine situering van de gebruikte architectuur en gemaakte keuzes.
Daarna volgt de implementatie van de Android-app en de achterliggende service.
Tot slot worden enkele details rond reproduceerbaarheid aangehaald.
De uitgewerkte broncode kan teruggevonden worden in deze GitHub repository(TODO). % TODO github url

\section{Voorvereisten}
\label{sec:voorvereisten}
De proof-of-concept maakt gebruik van enkele bestaande tools om een werkende applicatie op te zetten.
Deze dienen vooraf ge\"{\i}nstalleerd te worden.

\subsection{Quarkus CLI}
\label{subsec:de-quarkus-cli}
De Quarkus commandline-interface tool (Quarkus CLI) kan gebruikt worden om een Quarkus-applicatie te genereren.
Deze tool kent vele installatiemogelijkheden, in deze bachelorproef werd ervoor gekozen om de package manager Chocolatey te gebruiken.
Na het installeren van deze tool wordt~\nameref{subsec:opzetten-quarkus-omgeving} mogelijk.
Het kent de bijkomende functionaliteiten om extensies toe te voegen, bij te werken of te verwijderen.
Bovendien bevordert het het updateproces van het raamwerk zelf door voorgedefinieerde acties van het Quarkus-team toe te passen tussen elke update in.
Hierdoor kan deze proof-of-concept met de steeds recentste versies van Quarkus 3 en haar extensies uitgevoerd worden.

\subsection{Java Software Development Kit}
\label{subsec:java-software-development-kit}
Naast de Quarkus CLI maakt een Quarkus applicatie ook gebruik van de Java Software Development Kit (Java SDK).
De SDK bevat een verzameling van functionaliteiten en documentatie die softwareontwikkelaars gebruiken om applicaties op te zetten.
Binnen het Java ecosysteem zijn er verschillende distributies van de Java SDK, met telkens andere implementaties van dezelfde functionaliteiten.
De voorkeur gaat in dit geval uit naar de Adoptium Eclipse Temurin distributie van Java 21, de huidige lange-termijnondersteuning versie.
Deze distributie is open-source en vereist geen betalende licentie.

\subsubsection{De Java Virtuele Machine}
Raamwerken binnen het Java ecosysteem, zoals Quarkus en Jetpack Compose, worden in de Java programmeertaal geschreven.
Ze maken daardoor gebruik van de Java SDK en de Java Virtuele Machine (JVM).
Concreet schrijven softwareontwikkelaars een applicatie bovenop deze raamwerken in programmeertalen bovenop de JVM\@, vaak is dit Java zelf.
Jetpack Compose is hier een uitzondering op waarbij softwareontwikkelaars gebruik maken van de Kotlin programmeertaal, zoals aangeraden door de ontwikkelaars achter Android.
Een build tool, in dit geval de Gradle build tool, spreekt een gespecialiseerde compiler aan om de geschreven code om te vormen naar code die leesbaarder is voor computers.
Het resultaat hiervan is Java bytecode die de JVM kan interpreteren en uitvoeren.
Android telefoons en servers gebruiken Java Virtuele Machines die ontworpen zijn voor hun interne infrastructuur en het besturingssysteem.

\subsection{Docker}
\label{subsec:docker}
Docker is een systeem vergelijkbaar met de Java Virtuele Machine.
Het bevat alle benodigdheden om software te draaien binnen gecontaineriseerde instanties die ongeacht van de infrastructuur en het besturingssysteem op een reproduceerbare manier draaien.
Hiermee ontstaat de mogelijkheid om instructies te schrijven om bepaalde diensten op te zetten op een omgeving-agnostische manier, dit in de vorm van~\textit{Docker images}.
De Docker Engine voert de instructies van de Docker images uit op een manier waarin images geen zicht hebben op andere draaiende images en de rest van het systeem.

\subsubsection{Docker Desktop}
Docker Desktop is de Docker-toepassing die gebruikt zal worden voor deze proof-of-concept.
Met deze applicatie kunnen Docker images opgezet worden om te draaien in Docker containers.
Om dit te bereiken creëert de Docker Desktop applicatie intern een virtuele machine die Linux draait waarop deze containers vervolgens draaien.

\section{Omgevingen opzetten en testen}
\label{sec:omgevingen-opzetten}
De drie lagen van de~\nameref{subsubsec:architectuur} kennen verschillende architecturele beslissingen, deze worden hieronder toegelicht.

\subsection{Opzetten Google Gemini omgeving}
\label{subsec:opzetten-google-gemini-omgeving}
%Hier wordt het AI-platform opgezet om objectherkenning en suggereren van fitnessschema's mogelijk te maken TODO
TODO

\subsubsection{Tokens binnen een verzoek aan een AI-model}
TODO % todo uitleggen wat zijn tokens & hoe ze verminderen ----> misschien in literatuurstudie?

\subsection{Opzetten van de Quarkus omgeving}
\label{subsec:opzetten-quarkus-omgeving}
De Quarkus commandline-interface tool Quarkus CLI maakt het genereren en beheren van Quarkus-applicaties mogelijk.
Gezien we gebruik willen maken van het Kotlin-ecosysteem om consistent te blijven met onze Android-app zal de Kotlin extensie toegevoegd worden samen met enkele andere Quarkus-extensies:
\begin{itemize}
    \item \textbf{Hibernate ORM Panache Kotlin} zal de gegevens van de gebruikers en personal trainer opslaan in de databank op een Kotlin-gerichte wijze.
    \item \textbf{Java Database Connectivity (JDBC)} verzorgt de connectie met de databank zelf.
    JDBC haalt de inloggegevens van de databank op uit de application.properties bestand van de Quarkus-app.
    Als deze niet gedefinieerd zijn, dan zal Quarkus zelf een databank opstarten in een Docker-container en dit doorgeven aan JDBC\@.
    \item \textbf{Hibernate Validator} vergemakkelijkt het valideren van binnenkomende data van gebruikers.
    Langs deze weg verplicht de API de gebruiker om een foto mee in het verzoek te versturen.
    \item \textbf{LangChain4j}, tenslotte, maakt de communicatie met de Google Gemini-omgeving mogelijk.
\end{itemize}
Met de voornoemde specificaties in het achterhoofd gehouden kan deze commando uitgevoerd worden om het Quarkus-project op te zetten:
\begin{mdframed}[backgroundcolor=bg]
    \begin{minted}[breaklines]{sh}
quarkus create app mauricecantaert:bachelorproef-ti-quarkus \
    --extensions=kotlin,rest,rest-jackson,hibernate-orm-panache-kotlin,hibernate-validator,jdbc-mariadb,quarkus-langchain4j-core \
    --gradle-kotlin-dsl
    \end{minted}
\end{mdframed}

\subsubsection{De werking van een Quarkus API}
\label{subsubsec:werking-api}
De achterliggende service is geschreven volgens de principes van de REST-architectuur.
REST, of Representational State Transfer, is een vorm van een Application Programming Interface (API) dat het communiceren tussen apparaten via het internet standaardiseert~\autocite{Doglio2018}.
De voornaamste vereiste van een REST-applicatie is het behandelen van elk verzoek als nieuwe taak die telkens reproduceerbaar is.
Daaropvolgende verzoeken kennen geen geschiedenis van voorgaande verzoeken, waardoor het noodzakelijk is om steeds alle data mee te geven in één verzoek.

\subsubsection{Het aanspreken van functionaliteiten binnen de Quarkus API}
Elke bron, of type verzoek, krijgt volgens de REST-architectuur een Uniforme Bronidentificatie (URI) die gebruikt kan worden om de achterliggende dienst aan te spreken.
Deze Quarkus API kent daarmee twee bronnen, één voor de gebruikers en één voor personal trainers.
Gebruikers krijgen daarbij de mogelijkheid om fitnessinstrumenten te detecteren en daarvoor suggesties te laten genereren.
Personal trainers krijgen zicht op de geschiedenis van gebruikers en kunnen de suggesties bijsturen waar nodig.
Concreet spreekt de Android-app de achterliggende service aan met de gewenste URI's.

\subsection{Opzetten Jetpack Compose Android-app omgeving}
\label{subsec:opzetten-jetpack-compose-android-app}
Cliënten horen de mogelijkheid te hebben om de opgezette Quarkus applicatie op te roepen vanuit een Android applicatie.
Gebruikers kiezen daarvoor om een nieuwe foto te maken of een bestaande te selecteren uit de galerij van hun telefoon.
Het Android besturingssysteem verplicht applicaties om hiervoor eerst toestemming te vragen aan de gebruiker, wat geïmplementeerd zal worden door gebruik te maken van het bestaande proces dat het besturingssysteem beschikbaar stelt.
Tot slot zal Retrofit, een bestaande oplossing om REST-verzoeken te versturen en ontvangen, de connectie met de Quarkus dienst behandelen.
Android Studio, de geïntegreerde ontwikkelaarsomgeving voor ontwikkelaars op het Android platform, biedt een template aan voor het genereren van een Android project.
Deze maakt standaard gebruik van het Gradle bouwsysteem, wat de Quarkus api tevens ook gebruikt.

\subsection{Gemini AI testen}
\label{subsec:gemini-ai-testen}
TODO % todo

\section{Functionaliteiten uitwerken}
\label{sec:functionaliteiten-uitwerken}
De resultaten uit de vorige stap bewijzen de mogelijkheden van het Gemini-platform, hiermee ontstaat de zekerheid dat de proof-of-concept hier verder op zal kunnen bouwen.
Eerst volgt de opzet van het domeinmodel in de achterliggende service, dit dient om de historiek van de gebruiker bij te kunnen houden in de databank.
Daarna volgt een uitwerking van de bronnen die de gebruiker en de personal trainer zal kunnen oproepen om de functionaliteiten te gebruiken.
De gebruiker zal deze bronnen kunnen oproepen door middel van een kleine Android-app, wat in de laatste stap opgezet wordt.
Met een demo ontstaat een zicht op de bereikte functionaliteiten en de resultaten, wat besproken zal worden in de volgende sectie.

\subsection{Domeinmodel opzetten}
\label{subsec:domeinmodel-opzetten}
De achterliggende service hoort de historiek van de gebruiker bij te houden zodat de coach deze op elk moment hoort te kunnen raadplegen.
Om dit te bereiken zullen de resultaten, zoals gezien in subsectie~\ref{subsec:gemini-ai-testen}, ingedeeld worden als objecten.
De Quarkus applicatie houdt de ingezonden afbeelding niet bij in de databank om de privacy van de gebruiker te bewaren, het verwerkt deze enkel zoals beschreven in~\nameref{subsubsec:werking-api}.
Vertex AI verwerkt verzoeken van de Quarkus applicatie en stuurt deze terug in het vooraf opgestelde JSON-formaat.
Quarkus zal dit formaat terug omzetten naar het gepaste domein object om vervolgens te bewaren in de historiek van de gebruiker.
Afbeelding X beschrijft de topologie van het uitgewerkte domeinmodel. %TODO foto invoegen

\subsection{Functionaliteiten van de gebruiker uitwerken}
\label{subsec:functionaliteiten-van-de-gebruiker-uitwerken}
Na het opzetten van het domeinmodel kunnen de bronnen voor de gebruikers gedefinieerd en geïmplementeerd worden.
Voor deze proof-of-concept is er hierbij slechts een bron blootgesteld aan de gebruiker, namelijk het doorsturen van een foto.
In de achtergrond zal de applicatie de opgevraagde gegevens en de resultaten bijhouden in de databank.
De bron stuurt de suggesties door naar de gebruiker zodat de persoon verder kan met zijn workout.
Hierbij kijkt de applicatie naar de input van de personal trainer en past het de suggesties aan waar nodig.
Belangrijk hierbij is dat de gebruiker hier geen extra input voor moet geven.

\subsubsection{Bron definiëren}
TODO % TODO code over resource hier kort tonen, dit wordt in volgende stap dan gebruikt om langchain4j op te roepen en daarna op te slaan in hibernate

\subsubsection{Bron oproepen vanuit de Android applicatie}
TODO % TODO Retrofit, vragen voor permissie, foto versturen, tekst ontvangen

\subsubsection{Objectherkenning en generatieve AI toepassen}
TODO % TODO aanroepen van bron voert deze code uit, Langchain4j gebruiken en suggesties van PT halen uit DB

\subsubsection{Resultaten terugsturen en historiek bijhouden}
TODO % TODO langchain4j resultaten terugsturen naar gebruiker, historiek opslaan in DB

\subsection{Functionaliteiten van de personal trainer uitwerken}
\label{subsec:functionaliteiten-van-de-personal-trainer-uitwerken}
Een personal trainer krijgt toegang tot twee bronnen.
Om de applicatie te gebruiken start hij met het raadplegen van de historiek van de gebruiker.
Met deze gegevens krijgt hij een globaal zicht op de vooruitgang van de gebruiker, bijvoorbeeld aan de hand van het gewicht van enkele gebruikte toestellen.
Ook krijgt hij een zicht op de hoeveelheid toestellen die gebruikt werden, hoe vaak en over welke periode.
Hiermee hoeven zowel de coach als de cliënt dit niet zelf bij te houden of te noteren.
De tweede bron bestaat uit het manipuleren van toekomstige suggesties die aan de cliënt voorgesteld zullen worden, dit aan de hand van de gegevens uit de voorgenoemde bron.
Met het toevoegen van enkele suggesties, zoals het focussen op een bepaalde oefening of meer repetities aan een lager gewicht, zal de gebruiker gepersonaliseerde suggesties krijgen bij het volgende gebruik van de Android app.
Bovendien zal de coach deze gegevens niet zelf nog bij te houden, deze zullen telkens raadpleegbaar blijven in de databank bij volgende consultaties.

\subsubsection{Historiek van de gebruiker raadplegen}
TODO % TODO api call in postman tonen, bron definieren is zoals in vorige stap al uitgelegd

\subsubsection{Toekomstige suggesties manipuleren}
TODO % TODO met data uit historiek dan aanpassen

\subsection{Opmerkingen}
\label{subsec:opmerkingen}
TODO % TODO

\section{Reproduceren van de proof-of-concept}
\label{sec:reproduceren-van-de-proof-of-concept}
%Uitleggen waarom dit belangrijk is (zie cursus RM) TODO
TODO % uitleggen waarom reproduceren belangrijk is en wat er gedaan is om dit mogelijk te maken

\subsection{Gebruikte hardware en software}
\label{subsec:gebruikte-hardware-en-software}
TODO % verklaren welke software nodig is om de PoC te reproduceren en op welke hardware de testen zijn uitgevoerd TODO

\subsection{Automatisatie script}
\label{subsec:automatisatie-script}
%Docker script, jar file vanuit gradle builden enz TODO
TODO % verklaren welke script gebruikt moet worden om te reproduceren

\section{Resultaten}
\label{sec:resultaten}
% TODO
TODO % demonstratie \& screenshots vanuit het perspectief van de gebruiker en de trainer